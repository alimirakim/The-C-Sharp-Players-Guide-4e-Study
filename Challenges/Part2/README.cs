// # Part 2: Object-Oriented Programming

// ## Level 15: Object-Oriented Concepts
// #### Knowledge Check: Objects
// ## Level 16: Enumerations
// ### Enumeration Basics
// #### Defining an Enumeration
// #### Using an Enumeration
// #### Revisiting `ConsoleColor`
// #### Challenge: Simula's Test
// ### Underlying Types
// ## Level 17: Tuples
// ### The Basics of Tuples
// ### Tuple Element Names
// ### Tuples and Methods
// ### More Tuple Examples
// ### Deconstructing Tuples
// #### Ignoring Elements with Discards
// ### Tuples and Equality
// #### Challenge: Simula's Soups
// ## Level 18: Classes
// ### Defining a New Class
// ### Instances of Classes
// ### Constructors
// #### Constructors with Parameters
// #### Multiple Constructors
// #### Initializing Fields Inline
// #### Name Hiding
// #### The `this` Keyword
// #### Calling Other Constructors with `this`
// #### Leaving Off the Class Name
// ### Object-Oriented Design
// #### Challenge: Vin Fletcher's Arrows
// ## Level 19: Information Hiding
// ### The `public` and `private` Accessibility Modifiers
// #### The Default Accessibility Level is `private`
// #### When to Use `private` and `public`
// #### Accessibility Levels as Guidelines, Not Laws
// ### Abstractions
// ### Type Accessibility Levels and the `internal` Modifier
// #### Challenge: Vin's Trouble
// ## Level 20: Properties
// ### The Basics of Properties
// ### Auto-Implemented Properties
// ### Immutable Fields and Properties
// ### Object Initializer Syntax and Init Properties
// #### Challenge: The Properties of Arrows
// ### Anonymous Types
// ## Level 21: Static
// ### Static Members
// #### Static Fields
// #### Global State
// #### Static Properties
// #### Static Methods
// #### Static Constructors
// ### Static Classes
// #### Challenge: Arrow Factories
// ## Level 22: Null References
// ### Checking for Null
// ### Choosing When to Allow Null
// ## Level 23: Object-Oriented Design
// ### Requirements
// ### Designing the Software
// #### Noun Extraction
// #### UML
// #### CRC Cards
// #### Evaluating a Design
// ### Creating Code
// ### How to Collaborate
// #### Creating New Objects
// #### Constructor Parameters
// #### Method Parameters
// #### Asking Another Object
// #### Supplying the Reference via Property or Method
// #### Static Members
// #### Choices, Choices
// ### Baby Steps
// ## Level 24: The Catacombs of the Class
// ### The Five Prototypes
// #### Boss Battle: The Point
// #### Boss Battle: The Color
// #### Boss Battle: The Card
// #### Boss Battle: The Locked Door
// #### Boss Battle: The Password Validator
// ### Object-Oriented Design
// #### Boss Battle: Rock-Paper-Scissors
// #### Boss Battle: 15-Puzzle
// #### Boss Battle: Hangman
// ### Tic-Tac-Toe
// #### Boss Battle: Tic-Tac-Toe
// ## Level 25: Inheritance
// ### Inheritance and the `object` class
// ### Choosing Base Classes
// ### Constructors
// ### Casting and Checking for Types
// ### The `protected` Access Modifier
// ### Sealed Classes
// #### Challenge: Packing Inventory
// ## Level 26: Polymorphism
// ### Abstract Methods and Classes
// ### New Methods
// #### Challenge: Labeling Inventory
// #### Challenge: The Old Robot
// ## Level 27: Interfaces
// ### Defining Interfaces
// ### Implementing Interfaces
// ### Interfaces and Base Classes
// ### Explicit Interface Implementations
// ### Default Interface Methods
// #### Supporting Default Interface Methods
// #### Should I Use Default Interface Methods?
// #### Challenge: Robotic Interface
// ## Level 28: Structs
// ### Classes vs. Structs
// #### Rules to Follow When Making Structs
// ### Built-In Type Aliases
// ### Boxing and Unboxing
// #### Challenge: Room Coordinates
// ## Level 29: Records
// ### Records
// #### Additional Members
// #### Replacing Synthesized Members
// #### Records are Classes
// #### Inheritance
// #### Non-Positional Records
// ### `with` Expressions
// ### Classes, Records, or Structs?
// #### Challenge: War Preparations
// ## Level 30: Generics
// ### The Motivation for Generics
// ### Defining a Generic Type
// #### Multiple Generic Type Parameters
// #### Inheritance and Generic Types
// ### Generic Methods
// ### Generic Type Constraints
// #### Multiple Constraints
// #### Constraints on Methods
// ### The `default` Operator
// #### Challenge: Colored Items
// ## Level 31: The Fountain of Objects
// ### The Main Challenge
// #### Boss Bottle: The Fountain of Objects
// ### Expansions
// #### Boss Bottle: Small, Medium, or Large
// #### Boss Bottle: Pits
// #### Boss Bottle: Maelstroms
// #### Boss Bottle: Amaroks
// #### Boss Bottle: Getting Armed
// #### Boss Bottle: Getting Help
// ## Level 32: Some Useful Types
// ### The `Random` Class
// #### Challenge: The Robot Pilot
// ### The `DateTime` Struct
// ### The `TimeSpan` Struct
// ### Challenge: Time in the Cavern
// ### The `Guid` Struct
// ### The `List<T>` Class
// #### Creating List Indexes
// #### Indexing
// #### Adding and Removing Items from List
// #### `foreach` Loops
// #### Other Useful Things
// #### Challenge: List of Commands
// ### The `IEnumerable<T>` Interface
// ### The `Dictionary<TKey, TValue>` Class
// #### Types Besides `string`
// #### Dictionary Keys Should Not Change
// ### The `Nullable<T>` Struct
// ### `ValueTuple` Structs
// ### The `StringBuilder` Class